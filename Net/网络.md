<!-- 网络.md -->
### 1. http的版本
1. HTTP0.9只支持GET，不支持请求头，只有返回HTML字符串的能力，服务器响应后关闭TCP连接。
2. HTTP1.0增加多种请求方法（POST、DELETE、PUT、HEADER），增加请求头和响应头，可以传输多种数据格式。默认是短连接，每次与服务器交互都需要新建一个连接TCP。前一个请求响应到达之后下一个请求才能发送。
3. HTTP1.1增加多种请求方法（PUT、PATCH、OPTIONS、DELETE），默认使用持久化连接（Connection:keep-alive），多次请求由一个tcp连接完成，当并发多个请求需要多个TCP连接，每次TCP连接都需要三次握手四次挥手，浏览器为了控制资源会有6-8个TCP连接限制（chrome为6）。
4. HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。同域名下所有通信都在单个连接上完成，消除了因多个TCP连接而带来的延时和内存消耗；单个连接上可以并行交错的请求和响应，之间互不干扰，同一时刻可以传输多个HTTP请求。允许服务端推送。

### 2. http2.0的流和帧的概念
二进制协议将通信数据分解为更小的帧，数据帧在C/S的双向数据流中不断运输。

二进制分帧的几个概念（前面包含多个后面的）
1. 链接Link：指的是一条C/S之间的TCP链接
2. 数据流Stream：已建立的TCP连接的双向字节流，TCP中可以有一条或者多条消息
3. 消息Message：消息属于一个数据流，消息就是逻辑请求或响应消息对应的完整的一系列帧，也就是帧组成了消息
4. 帧Frame：帧是通信的最小单位，每个真都包含帧头和消息体，标识出当前帧所属的数据流（帧中有流标识符）


### 3. cookie、session和token的区别
1. cookie储存在客户端，最大长度不超过4KB。
2. session储存在服务器（运用加密算法），客户端只需要储存 sessionId 就可以维持登录状态，客户端在 cookies 中携带 sessionId，访问登录接口，获得用户信息。服务端检查 sessionId 合法性，以及是否过期，但是耗费服务端性能。优点:速度快，安全；缺点：服务器是有状态的。多台后端服务器无法共享 session。解决方法是，专门准备一台 session 服务器，关于 session 的所有操作都交给它来调用
3. token，服务器不需要存储Session状态

### 4. dns解析过程(m.xyz.com 查 y.abc.com)
> dns使用的udp协议
> A 指定主机名对应的IP地址，域名 ==> IP
> CNAME 这种记录允许您将多个名字映射到另外一个域名，域名 ==> 域名
1. 迭代查询

主机(m.xyz.com) -> **本地DNS服务器**(dns.xyz.com) -> 根域名DNS服务器 -> 顶级域名服务器(dns.com) -> 权限域名服务器(dns.abc.com) -(IP)-> **本地DNS服务器** -(IP)-> 主机

2. 递归查询

主机(m.xyz.com) -> **本地DNS服务器**(dns.xyz.com) -> 根域名DNS服务器 -> 顶级域名服务器(dns.com) -> 权限域名服务器(dns.abc.com) -(IP)-> 顶级域名服务器 -(IP)-> 根域名DNS服务器 -(IP)-> **本地DNS服务器** -(IP)-> 主机

### 5. CDN原理
网络请求直接访问源服务器比较费时，通过cdn把源站的内容缓存到多个服务节点，用户访问时就向最近的站点请求响应。

具体步骤：

1. 用户向(www.test.com)请求图片资源
2. 向Local DNS请求域名解析
3. 解析www.test.com时，发现其配置了CNAME（别名），解析请求就会发送到对应的云平台的DNS服务器上
4. Local DNS获取云平台DNS服务器返回的解析IP
5. 用户获取解析IP，发起对图片资源的请求
6. 若该IP对应节点有缓存该资源则直接返回，没有则需要向源服务站点发起对该资源的请求
7. 获取该资源后，该IP站点会根据缓存策略进行缓存，并返回给用户

### 6. 跨域的解决方案
1. jsonp（只支持GET）
```js
// 原理是在前端创建script标签，通过script不会被同源策略影响来实现访问
function search(value){
  // 将前端的回调函数返回给后端，后端返回带有参数的fn函数
  jsonp(`http://www.baidu.com/...cb=fn`);
}
function jsonp(url){
  var ele = document.createElement('script');
  ele.setAttribute('src', url);
  document.getElementsByTagName('head')[0].appendChild(ele);
}

function fn(res){
  // 前端写好的逻辑
}
```
2. cors（Cross-origin resource sharing 跨站资源共享）
```js
'Access-Control-Allow-Headers' : '允许的Content-Type'
'Access-Control-Allow-Methods' : '允许的请求方法'
'Access-Control-Max-Age' : '预请求允许其他方法和类型传输的时间'
```
3. hash
4. postMessage：该方法只解决了前端两个窗口的通信，但无法解决前后台调用的跨域问题。一般是主html和iframe之间的通信
5. WebSoket：WebSocket是不受同源限制的，所以跨域什么的就不存在了。
6. http-proxy
```
// vue框架的vue.config.js的proxyTable
```
7. 服务器使用代理
```js
// 前端
axios.get('http://localhost:3000/api', res => {
  // code...
})

// 后端
const Koa = require('koa')
const app = new Koa()
const proxy = require('koa-server-http-proxy')

app.use(proxy('/api', {
  target: 'http://localhost:8080/',
  changeOrigin: true
}))

app.listen(3000)
```


### 7. OPTIONS方法
1. 产生的条件：
  1. 必须是跨域请求
  2. 自定了请求头
  3. 请求头中的content-type是```application / x - www - form -urlencoded```，```text / plain```，```multipart / form-data```之外的格式


2. 作用
  1. 请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用来代替资源名称，向服务器发送 OPTIONS 请求
  2. 可以测试服务器功能是否正常。

### 8. 缓存相关(304)
[浏览器资源缓存相关](https://juejin.im/post/6844903801778864136)

强制缓存：Expires Cache-control

协商缓存：

请求头部 | 相应头部
--- | ---
If-None-Match（比较ETag是否不一致） | Etag（资源的唯一标识） 
If-Modified-Since（比较资源最后的更新时间是否一致） | Last-Modified（资源最后一次修改时间）

> 如果强缓存的资源，要强制更新缓存怎么办

1. 更换页面的资源路径，浏览器就会识别成不同的资源，即实现更新资源的效果
```html
<link rel="stylesheet" href="a.css"/>

<link rel="stylesheet" href="a.css?v=1.0.0"/>  
```
2. 将文件内容与文件的地址相关联，即可实现资源更新，url同步更新。问题是部署前端项目的时候，会把静态资源和动态网页分开部署，前者主要部署在CDN上。

### 9. http与https的区别

> http

1. 无状态。每次请求都是相互独立的，因此需要session和cookie来校验身份
2. 明文传输。由于TCP/IP协议的工作机制决定了通信内容在链路上是可窥视的。
3. 不验证通信方的身份。
4. 无法证明报文的完整性。

> https 相比于http多了一层TLS（SSL），一个安全套接层。

![image](https://github.com/AddJunZ/Front-End/blob/master/img/http-https.png)

使用https后，http是先和ssl通信，再由ssl和tcp通信。具体可以看这个目录下的**加密算法.md**。协商的过程其实就说ssl层做的事情。
